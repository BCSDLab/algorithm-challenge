# Valid Anagram
---
## 문제 해결 방법
---
* 1
  * s와 t의 size를 비교해서 다를 경우 false 반환한다.
  * 해시맵에 s의 문자들을 저장한다.(키-값: 알파벳-갯수)
  * 해시맵에서 t의 문자들을 차감하며 그때 값이 0보다 작아지면 false를 반환한다.
  * 반복문을 빠져나오면 true를 반환한다.
* 2
  * 1번 방법에서의 해시맵을 벡터나 배열로 변경하여 같은 단계를 따른다.
  * c - 'a' 하여 인덱스 범위로 만든다.
* 3
  * 문자열들을 sort하여 그 두 결과가 같은 지에 따라 부울값을 반환한다.
---
## 자료구조 선택
---
* 해시맵
* 벡터
* 배열
## 성능
---
* 1
  * 해시맵에 접근할 때 O(log n)의 시간복잡도
  * O(n log n) / O(k) k는 알파벳 수 26
* 2
  * O(n) / O(k)
* 3
  * O(n log n) / O(1)
## 알게 된 것
---
* 백터와 정적 배열의 차이점
  * 백터는 힙 메모리, 배열은 스택
  * 배열은 확장 가능(유연), 배열은 약간 더 효율적
  * 배열은 캐시 지역성(CPU 캐시 히트), 메모리 할당 오버헤드(단순 포인터 이동), 메모리 레이아웃 등의 이유로 메모리 접근 속도가 더 빠르다.
  * 알파벳 26자처럼 작은 크기의 고정 데이터의 경우 배열을 쓰는 게 더 빠르다.
* 문자에 - 'a'를 할 수 있다.
  * 이 경우 인덱스 범위(0~25)로써 다룰 수 있다.
# Code

```cpp

class Solution {

 public:
  bool isAnagram(string s, string t) {
    if (s.length() != t.length()) return false;

    int count[26] = {0};

    for (char c : s) count[c - 'a']++;

    for (char c : t) {
      if (--count[c - 'a'] < 0) return false;
    }

    return true;
  }
};

```